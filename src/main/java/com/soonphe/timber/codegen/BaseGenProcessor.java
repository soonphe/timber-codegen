package com.soonphe.timber.codegen;

import com.google.common.collect.Sets;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import java.io.File;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;

/**
 * 通用基础Annotation Processor。代码生成注解处理
 * 实现AbstractProcessor注解处理器，process处理注解逻辑
 *
 * @author soonphe
 * @since 1.0
 */
@SuppressWarnings("unchecked")
public abstract class BaseGenProcessor<T extends Annotation> extends AbstractProcessor {

    protected final Class processAnnotation;
    protected Filer filer;
    protected Messager messager;
    protected Types types;
    protected Elements elements;

    public BaseGenProcessor(Class<T> tClass) {
        this.processAnnotation = tClass;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Sets.newHashSet(processAnnotation.getCanonicalName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        //返回用于创建新的源文件、类文件或辅助文件的文件管理器。
        this.filer = processingEnv.getFiler();
        //返回用于对类型进行操作的一些实用程序方法的实现。
        this.types = processingEnv.getTypeUtils();
        //返回用于对元素进行操作的一些实用程序方法的实现
        this.elements = processingEnv.getElementUtils();
        //返回用于报告错误、警告和其他通知的消息传递程序。
        this.messager = processingEnv.getMessager();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        /**
         * 获取class中所有的Element对象：在rt.jar包下，路径：javax.lang.model.element包下
         * PackageElement、表示包程序元素。提供对有关包及其成员的信息的访问。
         * TypeElement、表示类或接口程序元素。提供对有关类型及其成员的信息的访问。请注意，枚举类型是类的一种，注解类型是接口的一种。
         * VariableElement、表示字段、枚举常量、方法或构造函数参数、局部变量、资源变量或异常参数。
         * ExecutableElement、表示类或接口的方法、构造函数或初始值设定项（静态或实例），包括注释类型元素。
         * TypeParameterElement、表示泛型类、接口、方法或构造函数元素的形式类型参数。类型参数声明了一个TypeVariable。
         */
        Set<Element> annotatedClass = roundEnv.getElementsAnnotatedWith(processAnnotation);
        /**
         * 获取所有的类或接口，遍历生成代码
         * ElementFilter：过滤器，从元素集合中选择感兴趣的元素，返回的集合和列表是新的集合
         * typesIn：方法：选择TypeElement类型返回，也可以选择其他类型返回：如methodsIn选择方法元素返回、packagesIn选择包元素返回，fieldsIn选择属性字段元素返回
         */
        for (TypeElement e : ElementFilter.typesIn(annotatedClass)) {
            genCode(e, roundEnv);
        }
        return false;
    }

    /**
     * 生成java文件
     *
     * @param packageName     包名
     * @param pathStr         文件路径
     * @param typeSpecBuilder 源码描述
     * @param override
     */
    public void genJavaFile(String packageName, String pathStr, TypeSpec.Builder typeSpecBuilder, boolean override) {
        JavaFile javaFile = JavaFile
                .builder(packageName, typeSpecBuilder.build())
                .addFileComment("---Auto Generated by codegen ---")
                .build();
        try {
            Path path = Paths.get(pathStr);
            File file = new File(path.toFile().getAbsolutePath());
            //File类型写入为java
            javaFile.writeTo(file);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }

    /**
     * 生成Target源码文件
     *
     * @param packageName
     * @param typeSpecBuilder
     */
    public void genJavaFileToTarget(String packageName, TypeSpec.Builder typeSpecBuilder) {
        JavaFile javaFile = JavaFile.builder(packageName, typeSpecBuilder.build()).build();
        try {
            //Filer类型写入为class
            javaFile.writeTo(filer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取elements所有属性字段，并根据predicate过滤
     *
     * @param elements  Element List
     * @param predicate 断言方法
     * @return
     */
    public Set<VariableElement> filterFields(List<? extends Element> elements, Predicate<Element> predicate) {
        Set<VariableElement> variableElements = ElementFilter.fieldsIn(elements).stream()
                .filter(predicate).collect(Collectors.toSet());
        return variableElements;
    }

    /**
     * 添加属性描述：根据@FieldDesc注解中的name字段
     *
     * @param ve
     * @return
     */
    protected String getFieldDesc(VariableElement ve) {
        return Optional.ofNullable(ve.getAnnotation(FieldDesc.class))
                .map(s -> s.name()).orElse(ve.getSimpleName().toString());
    }

    /**
     * 获取父类TypeElement
     *
     * @param element
     * @return
     */
    public TypeElement getSuperClass(TypeElement element) {
        TypeMirror parent = element.getSuperclass();
        /**
         * 判断类型
         * DeclaredType：表示已声明的类型，可以是类类型，也可以是接口类型。这包括参数化类型，如java.util.Set＜String＞以及原始类型。
         */
        if (parent instanceof DeclaredType) {
            Element elt = ((DeclaredType) parent).asElement();
            if (elt instanceof TypeElement) {
                return (TypeElement) elt;
            }
        }
        return null;
    }

    /**
     * 生成代码——虚方法
     *
     * @param e
     * @param roundEnvironment
     */
    protected abstract void genCode(TypeElement e, RoundEnvironment roundEnvironment);
}
